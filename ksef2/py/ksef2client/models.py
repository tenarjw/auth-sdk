# generated by datamodel-codegen:
#   filename:  https://ksef-test.mf.gov.pl/docs/v2/openapi.json
#   timestamp: 2025-10-10T18:11:52+00:00

# https://pypi.org/project/datamodel-code-generator/
# pip install datamodel-code-generator
# datamodel-codegen --url https://ksef-test.mf.gov.pl/docs/v2/openapi.json --input-file-type openapi --output-model-type pydantic_v2.BaseModel --output src/ksef_client/models2.py
# zmiana 28 stycznia 2026 - spowodowana radosną twórczością MF,,,
# zamieniam extra='forbid' na extra='ignore',
# JW 


from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Dict, List, Optional

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, Field, conint, constr


class AllowedIps(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    ip4Addresses: Optional[List[str]] = Field(
        None,
        description='Lista adresów IPv4 w notacji dziesiętnej kropkowanej, np. `192.168.0.10`.',
    )
    ip4Ranges: Optional[List[str]] = Field(
        None,
        description='Lista adresów IPv4 podana w formie zakresu początek–koniec, oddzielonego pojedynczym myślnikiem, np. `10.0.0.1–10.0.0.254`.',
    )
    ip4Masks: Optional[List[str]] = Field(
        None, description='Lista adresów IPv4 w notacji CIDR, np. `172.16.0.0/16`.'
    )


class AmountType(Enum):
    Brutto = 'Brutto'
    Netto = 'Netto'
    Vat = 'Vat'


class AttachmentPermissionGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    nip: str


class AttachmentPermissionRevokeRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    nip: str


class AuthenticationChallengeResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    challenge: str = Field(..., description='Unikalny challenge.')
    timestamp: AwareDatetime = Field(..., description='Czas wygenerowania challenge-a.')


class AuthenticationContextIdentifierType(Enum):
    Nip = 'Nip'
    InternalId = 'InternalId'
    NipVatUe = 'NipVatUe'
    PeppolId = 'PeppolId'


class AuthenticationMethod(Enum):
    Token = 'Token'
    TrustedProfile = 'TrustedProfile'
    InternalCertificate = 'InternalCertificate'
    QualifiedSignature = 'QualifiedSignature'
    QualifiedSeal = 'QualifiedSeal'
    PersonalSignature = 'PersonalSignature'
    PeppolSignature = 'PeppolSignature'


class AuthenticationTokenStatus(Enum):
    Pending = 'Pending'
    Active = 'Active'
    Revoking = 'Revoking'
    Revoked = 'Revoked'
    Failed = 'Failed'


class AuthorizationPolicy(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    allowedIps: Optional[AllowedIps] = Field(
        None, description='Lista dozwolonych adresów IP.'
    )


class BatchFilePartInfo(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    ordinalNumber: conint(ge=1) = Field(
        ..., description='Numer sekwencyjny części pliku paczki.'
    )
    fileName: str = Field(..., description='Nazwa części pliku paczki.')
    fileSize: conint(ge=1, le=104857600) = Field(
        ...,
        description='Rozmiar części pliku paczki w bajtach. Maksymalna dozwolona wartość to 100MiB (104 857 600 bajtów).',
    )
    fileHash: str = Field(
        ...,
        description='Skrót SHA256 części pliku paczki, zakodowany w formacie Base64.',
    )


class BatchSessionContextLimitsOverride(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxInvoiceSizeInMib: conint(ge=0, le=5) = Field(
        ..., description='Maksymalny rozmiar faktury w MiB.'
    )
    maxInvoiceWithAttachmentSizeInMib: conint(ge=0, le=10) = Field(
        ..., description='Maksymalny rozmiar faktury z załącznikiem w MiB.'
    )
    maxInvoices: conint(ge=0, le=100000) = Field(
        ...,
        description='Maksymalna ilość faktur które można przesłać w pojedynczej sesji.',
    )


class BatchSessionEffectiveContextLimits(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxInvoiceSizeInMib: conint(ge=0) = Field(
        ..., description='Maksymalny rozmiar faktury w MiB.'
    )
    maxInvoiceWithAttachmentSizeInMib: conint(ge=0) = Field(
        ..., description='Maksymalny rozmiar faktury z załącznikiem w MiB.'
    )
    maxInvoices: conint(ge=0) = Field(
        ...,
        description='Maksymalna ilość faktur które można przesłać w pojedynczej sesji.',
    )


class BuyerIdentifierType(Enum):
    None_ = 'None'
    Other = 'Other'
    Nip = 'Nip'
    VatUe = 'VatUe'


class CertificateEffectiveSubjectLimits(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxCertificates: Optional[int] = None


class CertificateEnrollmentDataResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    commonName: str = Field(..., description='Nazwa powszechna.')
    countryName: str = Field(..., description='Kraj, kod ISO 3166.')
    givenName: Optional[str] = Field(None, description='Imię.')
    surname: Optional[str] = Field(None, description='Nazwisko.')
    serialNumber: Optional[str] = Field(None, description='Numer seryjny podmiotu.')
    uniqueIdentifier: Optional[str] = Field(None, description='Unikalny identyfikator.')
    organizationName: Optional[str] = Field(None, description='Nazwa organizacji.')
    organizationIdentifier: Optional[str] = Field(
        None, description='Identyfikator organizacji.'
    )


class CertificateLimit(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    remaining: int = Field(..., description='Pozostała wartość limitu.')
    limit: int = Field(
        ..., description='Maksymalna liczba zasobów dozwolona w ramach limitu.'
    )


class CertificateLimitsResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    canRequest: bool = Field(
        ...,
        description='Flaga informująca czy uwierzytelniony podmiot może złożyć nowy wniosek o certyfikat.',
    )
    enrollment: CertificateLimit = Field(
        ...,
        description='Informacje o limitach związanych z liczbą możliwych do złożenia wniosków certyfikacyjnych.',
    )
    certificate: CertificateLimit = Field(
        ...,
        description='Informacje o limitach dotyczących liczby aktywnych certyfikatów wydanych dla danego podmiotu.',
    )


class CertificateListItemStatus(Enum):
    Active = 'Active'
    Blocked = 'Blocked'
    Revoked = 'Revoked'
    Expired = 'Expired'


class CertificateRevocationReason(Enum):
    Unspecified = 'Unspecified'
    Superseded = 'Superseded'
    KeyCompromise = 'KeyCompromise'


class CertificateSubjectIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class CertificateSubjectLimitsOverride(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxCertificates: Optional[conint(ge=0)] = None


class CheckAttachmentPermissionStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    isAttachmentAllowed: Optional[bool] = Field(
        None,
        description='Informacja czy Podmiot ma obecnie możliwość dodawania Załączników do Faktur',
    )
    revokedDate: Optional[AwareDatetime] = Field(
        None,
        description='Data i czas zakończenia możliwość dodawania przez Podmiot Załączników do Faktur.\nBrak podanej daty oznacza bezterminową możliwość dodawania Załączników do Faktur',
    )


class CommonSessionStatus(Enum):
    InProgress = 'InProgress'
    Succeeded = 'Succeeded'
    Failed = 'Failed'
    Cancelled = 'Cancelled'


class CurrencyCode(Enum):
    AED = 'AED'
    AFN = 'AFN'
    ALL = 'ALL'
    AMD = 'AMD'
    ANG = 'ANG'
    AOA = 'AOA'
    ARS = 'ARS'
    AUD = 'AUD'
    AWG = 'AWG'
    AZN = 'AZN'
    BAM = 'BAM'
    BBD = 'BBD'
    BDT = 'BDT'
    BGN = 'BGN'
    BHD = 'BHD'
    BIF = 'BIF'
    BMD = 'BMD'
    BND = 'BND'
    BOB = 'BOB'
    BOV = 'BOV'
    BRL = 'BRL'
    BSD = 'BSD'
    BTN = 'BTN'
    BWP = 'BWP'
    BYN = 'BYN'
    BZD = 'BZD'
    CAD = 'CAD'
    CDF = 'CDF'
    CHE = 'CHE'
    CHF = 'CHF'
    CHW = 'CHW'
    CLF = 'CLF'
    CLP = 'CLP'
    CNY = 'CNY'
    COP = 'COP'
    COU = 'COU'
    CRC = 'CRC'
    CUC = 'CUC'
    CUP = 'CUP'
    CVE = 'CVE'
    CZK = 'CZK'
    DJF = 'DJF'
    DKK = 'DKK'
    DOP = 'DOP'
    DZD = 'DZD'
    EGP = 'EGP'
    ERN = 'ERN'
    ETB = 'ETB'
    EUR = 'EUR'
    FJD = 'FJD'
    FKP = 'FKP'
    GBP = 'GBP'
    GEL = 'GEL'
    GGP = 'GGP'
    GHS = 'GHS'
    GIP = 'GIP'
    GMD = 'GMD'
    GNF = 'GNF'
    GTQ = 'GTQ'
    GYD = 'GYD'
    HKD = 'HKD'
    HNL = 'HNL'
    HRK = 'HRK'
    HTG = 'HTG'
    HUF = 'HUF'
    IDR = 'IDR'
    ILS = 'ILS'
    IMP = 'IMP'
    INR = 'INR'
    IQD = 'IQD'
    IRR = 'IRR'
    ISK = 'ISK'
    JEP = 'JEP'
    JMD = 'JMD'
    JOD = 'JOD'
    JPY = 'JPY'
    KES = 'KES'
    KGS = 'KGS'
    KHR = 'KHR'
    KMF = 'KMF'
    KPW = 'KPW'
    KRW = 'KRW'
    KWD = 'KWD'
    KYD = 'KYD'
    KZT = 'KZT'
    LAK = 'LAK'
    LBP = 'LBP'
    LKR = 'LKR'
    LRD = 'LRD'
    LSL = 'LSL'
    LYD = 'LYD'
    MAD = 'MAD'
    MDL = 'MDL'
    MGA = 'MGA'
    MKD = 'MKD'
    MMK = 'MMK'
    MNT = 'MNT'
    MOP = 'MOP'
    MRU = 'MRU'
    MUR = 'MUR'
    MVR = 'MVR'
    MWK = 'MWK'
    MXN = 'MXN'
    MXV = 'MXV'
    MYR = 'MYR'
    MZN = 'MZN'
    NAD = 'NAD'
    NGN = 'NGN'
    NIO = 'NIO'
    NOK = 'NOK'
    NPR = 'NPR'
    NZD = 'NZD'
    OMR = 'OMR'
    PAB = 'PAB'
    PEN = 'PEN'
    PGK = 'PGK'
    PHP = 'PHP'
    PKR = 'PKR'
    PLN = 'PLN'
    PYG = 'PYG'
    QAR = 'QAR'
    RON = 'RON'
    RSD = 'RSD'
    RUB = 'RUB'
    RWF = 'RWF'
    SAR = 'SAR'
    SBD = 'SBD'
    SCR = 'SCR'
    SDG = 'SDG'
    SEK = 'SEK'
    SGD = 'SGD'
    SHP = 'SHP'
    SLL = 'SLL'
    SOS = 'SOS'
    SRD = 'SRD'
    SSP = 'SSP'
    STN = 'STN'
    SVC = 'SVC'
    SYP = 'SYP'
    SZL = 'SZL'
    THB = 'THB'
    TJS = 'TJS'
    TMT = 'TMT'
    TND = 'TND'
    TOP = 'TOP'
    TRY = 'TRY'
    TTD = 'TTD'
    TWD = 'TWD'
    TZS = 'TZS'
    UAH = 'UAH'
    UGX = 'UGX'
    USD = 'USD'
    USN = 'USN'
    UYI = 'UYI'
    UYU = 'UYU'
    UYW = 'UYW'
    UZS = 'UZS'
    VES = 'VES'
    VND = 'VND'
    VUV = 'VUV'
    WST = 'WST'
    XAF = 'XAF'
    XAG = 'XAG'
    XAU = 'XAU'
    XBA = 'XBA'
    XBB = 'XBB'
    XBC = 'XBC'
    XBD = 'XBD'
    XCD = 'XCD'
    XCG = 'XCG'
    XDR = 'XDR'
    XOF = 'XOF'
    XPD = 'XPD'
    XPF = 'XPF'
    XPT = 'XPT'
    XSU = 'XSU'
    XUA = 'XUA'
    XXX = 'XXX'
    YER = 'YER'
    ZAR = 'ZAR'
    ZMW = 'ZMW'
    ZWL = 'ZWL'


class EncryptionInfo(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    encryptedSymmetricKey: str = Field(
        ...,
        description='Klucz symetryczny zaszyfrowany algorytmem RSA (Padding: OAEP z SHA-256), zakodowany w formacie Base64.\n\n[Klucz publiczny RSA](/public-keys/publicKey.pem)',
    )
    initializationVector: str = Field(
        ...,
        description='Wektor inicjalizujący (IV) używany do szyfrowania symetrycznego, zakodowany w formacie Base64.',
    )


class EnrollCertificateResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(
        ...,
        description='Numer referencyjny operacji przetwarzania wniosku certyfikacyjnego.',
    )
    timestamp: AwareDatetime = Field(
        ..., description='Data złożenia wniosku certyfikacyjnego.'
    )


class EnrollmentEffectiveSubjectLimits(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxEnrollments: Optional[int] = None


class EnrollmentSubjectLimitsOverride(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxEnrollments: Optional[conint(ge=0)] = None


class EntityAuthorizationPermissionType(Enum):
    SelfInvoicing = 'SelfInvoicing'
    RRInvoicing = 'RRInvoicing'
    TaxRepresentative = 'TaxRepresentative'
    PefInvoicing = 'PefInvoicing'


class EntityAuthorizationPermissionsSubjectIdentifierType(Enum):
    Nip = 'Nip'
    PeppolId = 'PeppolId'


class EntityAuthorizationsAuthorIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class EntityAuthorizationsAuthorizedEntityIdentifierType(Enum):
    Nip = 'Nip'
    PeppolId = 'PeppolId'


class EntityAuthorizationsAuthorizingEntityIdentifierType(Enum):
    Nip = 'Nip'


class EntityPermissionType(Enum):
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'


class EntityPermissionsSubjectIdentifierType(Enum):
    Nip = 'Nip'


class EntityPermissionsSubordinateEntityIdentifierType(Enum):
    Nip = 'Nip'


class EntityRoleType(Enum):
    CourtBailiff = 'CourtBailiff'
    EnforcementAuthority = 'EnforcementAuthority'
    LocalGovernmentUnit = 'LocalGovernmentUnit'
    LocalGovernmentSubUnit = 'LocalGovernmentSubUnit'
    VatGroupUnit = 'VatGroupUnit'
    VatGroupSubUnit = 'VatGroupSubUnit'


class EntityRolesParentEntityIdentifierType(Enum):
    Nip = 'Nip'


class EuEntityAdministrationPermissionsContextIdentifierType(Enum):
    NipVatUe = 'NipVatUe'


class EuEntityAdministrationPermissionsSubjectIdentifierType(Enum):
    Fingerprint = 'Fingerprint'


class EuEntityPermissionType(Enum):
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'


class EuEntityPermissionsAuthorIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class EuEntityPermissionsQueryPermissionType(Enum):
    VatUeManage = 'VatUeManage'
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'
    Introspection = 'Introspection'


class EuEntityPermissionsQueryRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    vatUeIdentifier: Optional[str] = Field(
        None, description='Identyfikator podmiotu unijnego.'
    )
    authorizedFingerprintIdentifier: Optional[str] = Field(
        None, description='Uprawniony odcisk palca certyfikatu.'
    )
    permissionTypes: Optional[List[EuEntityPermissionsQueryPermissionType]] = Field(
        None, description='Możliwe uprawnienia do filtrowania.'
    )


class EuEntityPermissionsSubjectIdentifierType(Enum):
    Fingerprint = 'Fingerprint'


class ExceptionDetails(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    exceptionCode: Optional[int] = None
    exceptionDescription: Optional[str] = None
    details: Optional[List[str]] = None


class ExceptionInfo(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    exceptionDetailList: Optional[List[ExceptionDetails]] = None
    referenceNumber: Optional[str] = None
    serviceCode: Optional[str] = None
    serviceCtx: Optional[str] = None
    serviceName: Optional[str] = None
    timestamp: Optional[AwareDatetime] = None


class ExceptionResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    exception: Optional[ExceptionInfo] = None


class ExportInvoicesResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    operationReferenceNumber: str = Field(
        ..., description='Numer referencyjny operacji.'
    )


class FormCode(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    systemCode: str = Field(..., description='Kod systemowy')
    schemaVersion: str = Field(..., description='Wersja schematu')
    value: str = Field(..., description='Wartość')


class GenerateTokenResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: Optional[str] = Field(
        None,
        description='Numer referencyjny tokena KSeF. Za jego pomocą można sprawdzić jego status lub go unieważnić.',
    )
    token: Optional[str] = Field(None, description='Token KSeF.')


class IndirectPermissionType(Enum):
    InvoiceRead = 'InvoiceRead'
    InvoiceWrite = 'InvoiceWrite'


class IndirectPermissionsSubjectIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class IndirectPermissionsTargetIdentifierType(Enum):
    Nip = 'Nip'
    AllPartners = 'AllPartners'


class InvoiceMetadataAuthorizedSubject(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    nip: str = Field(..., description='Nip podmiotu upoważnionego')
    name: Optional[str] = Field(None, description='Nazwa podmiotu upoważnionego.')
    role: int = Field(..., description='Rola podmiotu upoważnionego.')


class InvoiceMetadataBuyerIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: BuyerIdentifierType = Field(
        ...,
        description='Typ identyfikatora nabywcy.\n| Wartość | Opis |\n| --- | --- |\n| None | Brak identyfikatora nabywcy |\n| Other | Inny |\n| Nip | NIP |\n| VatUe | VAT UE |\n',
    )
    value: Optional[str] = Field(None, description='Wartośc identyfikatora nabywcy.')


class InvoiceMetadataSeller(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    nip: str = Field(..., description='Nip sprzedawcy.')
    name: Optional[str] = Field(None, description='Nazwa sprzedawcy.')


class InvoicePackagePart(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    ordinalNumber: conint(ge=1) = Field(
        ..., description='Numer sekwencyjny pliku części paczki.'
    )
    partName: str = Field(..., description='Nazwa pliku części paczki.')
    method: str = Field(
        ..., description='Metoda HTTP, której należy użyć przy pobieraniu pliku.'
    )
    url: AnyUrl = Field(
        ..., description='Adres URL, pod który należy wysłać żądanie pobrania.'
    )
    partSize: conint(ge=1, le=52428800) = Field(
        ...,
        description='Rozmiar części paczki w bajtach. Maksymalny rozmiar części to 50MiB (52 428 800 bajtów).',
    )
    partHash: str = Field(
        ...,
        description='Skrót SHA256 pliku części paczki, zakodowany w formacie Base64.',
    )
    encryptedPartSize: conint(ge=1) = Field(
        ..., description='Rozmiar zaszyfrowanej części paczki w bajtach.'
    )
    encryptedPartHash: str = Field(
        ...,
        description='Skrót SHA256 zaszyfrowanej części paczki, zakodowany w formacie Base64.',
    )
    expirationDate: AwareDatetime = Field(
        ..., description='Moment wygaśnięcia linku do pobrania części.'
    )


class InvoicePermissionType(Enum):
    SelfInvoicing = 'SelfInvoicing'
    TaxRepresentative = 'TaxRepresentative'
    RRInvoicing = 'RRInvoicing'
    PefInvoicing = 'PefInvoicing'


class InvoiceQueryAmount(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: AmountType
    from_: Optional[float] = Field(None, alias='from')
    to: Optional[float] = None


class InvoiceQueryBuyerIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: BuyerIdentifierType = Field(
        ...,
        description='Typ identyfikatora nabywcy.\n| Wartość | Opis |\n| --- | --- |\n| None | Brak identyfikatora nabywcy |\n| Other | Inny |\n| Nip | NIP |\n| VatUe | VAT UE |\n',
    )
    value: Optional[str] = Field(None, description='Wartość identyfikatora nabywcy.')


class InvoiceQueryDateType(Enum):
    Issue = 'Issue'
    Invoicing = 'Invoicing'
    PermanentStorage = 'PermanentStorage'


class InvoiceQueryFormType(Enum):
    FA = 'FA'
    PEF = 'PEF'
    RR = 'RR'


class InvoiceQuerySubjectType(Enum):
    Subject1 = 'Subject1'
    Subject2 = 'Subject2'
    Subject3 = 'Subject3'
    SubjectAuthorized = 'SubjectAuthorized'


class InvoiceType(Enum):
    Vat = 'Vat'
    Zal = 'Zal'
    Kor = 'Kor'
    Roz = 'Roz'
    Upr = 'Upr'
    KorZal = 'KorZal'
    KorRoz = 'KorRoz'
    VatPef = 'VatPef'
    VatPefSp = 'VatPefSp'
    KorPef = 'KorPef'
    VatRr = 'VatRr'
    KorVatRr = 'KorVatRr'


class InvoicingMode(Enum):
    Online = 'Online'
    Offline = 'Offline'


class KsefCertificateType(Enum):
    Authentication = 'Authentication'
    Offline = 'Offline'


class OnlineSessionContextLimitsOverride(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxInvoiceSizeInMib: conint(ge=0, le=5) = Field(
        ..., description='Maksymalny rozmiar faktury w MiB.'
    )
    maxInvoiceWithAttachmentSizeInMib: conint(ge=0, le=10) = Field(
        ..., description='Maksymalny rozmiar faktury z załącznikiem w MiB.'
    )
    maxInvoices: conint(ge=0, le=100000) = Field(
        ...,
        description='Maksymalna ilość faktur które można przesłać w pojedynczej sesji.',
    )


class OnlineSessionEffectiveContextLimits(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    maxInvoiceSizeInMib: conint(ge=0) = Field(
        ..., description='Maksymalny rozmiar faktury w MiB.'
    )
    maxInvoiceWithAttachmentSizeInMib: conint(ge=0) = Field(
        ..., description='Maksymalny rozmiar faktury z załącznikiem w MiB.'
    )
    maxInvoices: conint(ge=0) = Field(
        ...,
        description='Maksymalna ilość faktur które można przesłać w pojedynczej sesji.',
    )


class OpenOnlineSessionRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    formCode: FormCode = Field(
        ...,
        description='Schemat faktur wysyłanych w ramach sesji.\n\nObsługiwane schematy:\n| SystemCode | SchemaVersion | Value |\n| --- | --- | --- |\n| FA (2) | 1-0E | FA |\n| FA (3) | 1-0E | FA |\n| FA_PEF (3) | 2-1 | FA_PEF |\n| FA_KOR_PEF (3) | 2-1 | FA_PEF |\n',
    )
    encryption: EncryptionInfo = Field(
        ...,
        description='Symetryczny klucz szyfrujący pliki XML, zaszyfrowany kluczem publicznym Ministerstwa Finansów.',
    )


class OpenOnlineSessionResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(..., description='Numer referencyjny sesji.')
    validUntil: AwareDatetime = Field(
        ...,
        description='Termin ważności sesji. Po jego upływie sesja zostanie automatycznie zamknięta.',
    )


class PartUploadRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    ordinalNumber: conint(ge=1) = Field(
        ..., description='Numer sekwencyjny części pliku paczki.'
    )
    method: str = Field(
        ...,
        description='Metoda HTTP, której należy użyć przy wysyłce części pliku paczki.',
    )
    url: AnyUrl = Field(
        ..., description='Adres pod który należy wysłać część pliku paczki.'
    )
    headers: Dict[str, str] = Field(
        ...,
        description='Nagłówki, których należy użyć przy wysyłce części pliku paczki.',
    )


class PeppolProvider(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    id: Optional[str] = Field(None, description='Identyfikator dostawcy usług Peppol.')
    name: Optional[str] = Field(None, description='Nazwa dostawcy usług Peppol.')


class PermissionState(Enum):
    Active = 'Active'
    Inactive = 'Inactive'


class PermissionsOperationResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    operationReferenceNumber: str = Field(
        ...,
        description='Numer referencyjny asynchronicznej operacji nadawania lub odbierania uprawnień.',
    )


class PersonCreateRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    nip: str
    pesel: str
    isBailiff: bool
    description: str
    createdDate: Optional[AwareDatetime] = None


class PersonPermissionScope(Enum):
    CredentialsManage = 'CredentialsManage'
    CredentialsRead = 'CredentialsRead'
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'
    Introspection = 'Introspection'
    SubunitManage = 'SubunitManage'
    EnforcementOperations = 'EnforcementOperations'


class PersonPermissionType(Enum):
    CredentialsManage = 'CredentialsManage'
    CredentialsRead = 'CredentialsRead'
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'
    Introspection = 'Introspection'
    SubunitManage = 'SubunitManage'
    EnforcementOperations = 'EnforcementOperations'


class PersonPermissionsAuthorIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'
    System = 'System'


class PersonPermissionsAuthorizedIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class PersonPermissionsContextIdentifierType(Enum):
    Nip = 'Nip'
    InternalId = 'InternalId'


class PersonPermissionsQueryType(Enum):
    PermissionsInCurrentContext = 'PermissionsInCurrentContext'
    PermissionsGrantedInCurrentContext = 'PermissionsGrantedInCurrentContext'


class PersonPermissionsSubjectIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class PersonPermissionsTargetIdentifierType(Enum):
    Nip = 'Nip'
    AllPartners = 'AllPartners'


class PersonRemoveRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    nip: str


class PersonalPermissionScope(Enum):
    CredentialsManage = 'CredentialsManage'
    CredentialsRead = 'CredentialsRead'
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'
    Introspection = 'Introspection'
    SubunitManage = 'SubunitManage'
    EnforcementOperations = 'EnforcementOperations'
    VatUeManage = 'VatUeManage'
    Owner = 'Owner'


class PersonalPermissionType(Enum):
    CredentialsManage = 'CredentialsManage'
    CredentialsRead = 'CredentialsRead'
    InvoiceWrite = 'InvoiceWrite'
    InvoiceRead = 'InvoiceRead'
    Introspection = 'Introspection'
    SubunitManage = 'SubunitManage'
    EnforcementOperations = 'EnforcementOperations'
    VatUeManage = 'VatUeManage'


class PersonalPermissionsAuthorizedIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class PersonalPermissionsContextIdentifierType(Enum):
    Nip = 'Nip'


class PersonalPermissionsTargetIdentifierType(Enum):
    Nip = 'Nip'
    AllPartners = 'AllPartners'


class PublicKeyCertificateUsage(Enum):
    KsefTokenEncryption = 'KsefTokenEncryption'
    SymmetricKeyEncryption = 'SymmetricKeyEncryption'


class QueryCertificatesRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificateSerialNumber: Optional[str] = Field(
        None,
        description='Numer seryjny certyfikatu. Wyszukiwanie odbywa się na zasadzie dokładnego dopasowania (exact match).',
    )
    name: Optional[str] = Field(
        None,
        description='Nazwa własna certyfikatu. Wyszukiwanie jest częściowe, czyli zwracane są certyfikaty, których nazwa zawiera podany ciąg znaków (contains).',
    )
    type: Optional[KsefCertificateType] = Field(
        None,
        description='Typ certyfikatu KSeF.\n| Wartość | Opis |\n| --- | --- |\n| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |\n| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |\n',
    )
    status: Optional[CertificateListItemStatus] = Field(
        None,
        description='Status certyfikatu.\n| Wartość | Opis |\n| --- | --- |\n| Active | Certyfikat jest aktywny i może zostać użyty do uwierzytelnienia lub realizacji operacji w trybie offline (w zależności od typu certyfikatu). |\n| Blocked | Certyfikat został zablokowany i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline.            Status przejściowy do czasu zakończenia procesu unieważniania. |\n| Revoked | Certyfikat został unieważniony i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |\n| Expired | Certyfikat wygasł i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |\n',
    )
    expiresAfter: Optional[AwareDatetime] = Field(
        None, description='Filtruje certyfikaty, które wygasają po podanej dacie.'
    )


class QueryPeppolProvidersResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    peppolProviders: List[PeppolProvider] = Field(
        ..., description='Lista dostawców usług Peppol.'
    )
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryType(Enum):
    Granted = 'Granted'
    Received = 'Received'


class RetrieveCertificatesListItem(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificate: str = Field(
        ..., description='Certyfikat w formacie DER zakodowany w Base64.'
    )
    certificateName: str = Field(..., description='Nazwa własna certyfikatu.')
    certificateSerialNumber: str = Field(..., description='Numer seryjny certyfikatu.')
    certificateType: KsefCertificateType = Field(
        ...,
        description='Typ certyfikatu.\n| Wartość | Opis |\n| --- | --- |\n| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |\n| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |\n',
    )


class RetrieveCertificatesRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificateSerialNumbers: List[str] = Field(
        ..., description='Numery seryjne certyfikatów do pobrania.'
    )


class RetrieveCertificatesResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificates: List[RetrieveCertificatesListItem] = Field(
        ..., description='Pobrane certyfikaty.'
    )


class RevokeCertificateRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    revocationReason: Optional[CertificateRevocationReason] = Field(
        None,
        description='Powód unieważnienia certyfikatu.\n| Wartość | Opis |\n| --- | --- |\n| Unspecified | Nieokreślony. |\n| Superseded | Certyfikat został zastąpiony przez inny. |\n| KeyCompromise | Klucz prywatny powiązany z certyfikatem został skompromitowany. |\n',
    )


class SendInvoiceRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    invoiceHash: str = Field(
        ...,
        description='Skrót SHA256 oryginalnej faktury, zakodowany w formacie Base64.',
    )
    invoiceSize: conint(ge=1) = Field(
        ...,
        description='Rozmiar oryginalnej faktury w bajtach. Maksymalny rozmiar zależy od limitów ustawionych dla uwierzytelnionego kontekstu.',
    )
    encryptedInvoiceHash: str = Field(
        ...,
        description='Skrót SHA256 zaszyfrowanej faktury, zakodowany w formacie Base64.',
    )
    encryptedInvoiceSize: conint(ge=1) = Field(
        ..., description='Rozmiar zaszyfrowanej faktury w bajtach.'
    )
    encryptedInvoiceContent: str = Field(
        ...,
        description='Faktura zaszyfrowana algorytmem AES-256-CBC z dopełnianiem PKCS#7 (kluczem przekazanym przy otwarciu sesji), zakodowana w formacie Base64.',
    )
    offlineMode: Optional[bool] = Field(
        False,
        description='Określa, czy podatnik deklaruje tryb fakturowania "offline" dla przesyłanego dokumentu.',
    )
    hashOfCorrectedInvoice: Optional[str] = Field(
        None,
        description='Skrót SHA256 korygowanej faktury, zakodowany w formacie Base64. Wymagany przy wysyłaniu korekty technicznej faktury.',
    )


class SendInvoiceResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(..., description='Numer referencyjny faktury.')


class SessionType(Enum):
    Online = 'Online'
    Batch = 'Batch'


class SetSessionLimitsRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    onlineSession: OnlineSessionContextLimitsOverride = Field(
        ..., description='Limity dla sesji interaktywnych.'
    )
    batchSession: BatchSessionContextLimitsOverride = Field(
        ..., description='Limity dla sesji wsadowych.'
    )


class StatusInfo(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    code: int = Field(..., description='Kod statusu')
    description: constr(min_length=1) = Field(..., description='Opis statusu')
    details: Optional[List[str]] = Field(
        None, description='Dodatkowe szczegóły statusu'
    )


class SubjectIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'
    Token = 'Token'


class SubjectRemoveRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectNip: str


class SubjectType(Enum):
    EnforcementAuthority = 'EnforcementAuthority'
    VatGroup = 'VatGroup'
    JST = 'JST'


class SubordinateEntityRoleType(Enum):
    LocalGovernmentSubUnit = 'LocalGovernmentSubUnit'
    VatGroupSubUnit = 'VatGroupSubUnit'


class SubordinateRoleSubordinateEntityIdentifierType(Enum):
    Nip = 'Nip'


class Subunit(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectNip: str
    description: str


class SubunitPermissionScope(Enum):
    CredentialsManage = 'CredentialsManage'


class SubunitPermissionsAuthorIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class SubunitPermissionsContextIdentifierType(Enum):
    InternalId = 'InternalId'
    Nip = 'Nip'


class SubunitPermissionsSubjectIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class SubunitPermissionsSubunitIdentifierType(Enum):
    InternalId = 'InternalId'
    Nip = 'Nip'


class TestDataAuthorizedIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class TestDataContextIdentifierType(Enum):
    Nip = 'Nip'


class TestDataPermissionType(Enum):
    InvoiceRead = 'InvoiceRead'
    InvoiceWrite = 'InvoiceWrite'
    Introspection = 'Introspection'
    CredentialsRead = 'CredentialsRead'
    CredentialsManage = 'CredentialsManage'
    EnforcementOperations = 'EnforcementOperations'
    SubunitManage = 'SubunitManage'


class ThirdSubjectIdentifierType(Enum):
    Nip = 'Nip'
    InternalId = 'InternalId'
    VatUe = 'VatUe'
    Other = 'Other'
    None_ = 'None'


class TokenAuthorIdentifierType(Enum):
    Nip = 'Nip'
    Pesel = 'Pesel'
    Fingerprint = 'Fingerprint'


class TokenAuthorIdentifierTypeIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: TokenAuthorIdentifierType = Field(
        ...,
        description='Typ identyfikatora.\n| Wartość | Opis |\n| --- | --- |\n| Nip | NIP. |\n| Pesel | PESEL. |\n| Fingerprint | Odcisk palca certyfikatu. |\n',
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class TokenContextIdentifierType(Enum):
    Nip = 'Nip'
    InternalId = 'InternalId'
    NipVatUe = 'NipVatUe'
    PeppolId = 'PeppolId'


class TokenContextIdentifierTypeIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: TokenContextIdentifierType = Field(
        ...,
        description='Typ identyfikatora.\n| Wartość | Opis |\n| --- | --- |\n| Nip | NIP. |\n| InternalId | Identyfikator wewnętrzny. |\n| NipVatUe | Dwuczłonowy identyfikator składający się z numeru NIP i numeru VAT-UE: `{nip}-{vat_ue}`. |\n| PeppolId | Identyfikator dostawcy usług Peppol. |\n',
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class TokenInfo(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    token: str = Field(..., description='Token w formacie JWT.')
    validUntil: AwareDatetime = Field(..., description='Data ważności tokena.')


class TokenPermissionType(Enum):
    InvoiceRead = 'InvoiceRead'
    InvoiceWrite = 'InvoiceWrite'
    CredentialsRead = 'CredentialsRead'
    CredentialsManage = 'CredentialsManage'
    SubunitManage = 'SubunitManage'
    EnforcementOperations = 'EnforcementOperations'


class TokenStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: Optional[str] = Field(
        None, description='Numer referencyjny tokena.'
    )
    authorIdentifier: Optional[TokenAuthorIdentifierTypeIdentifier] = Field(
        None, description='Identyfikator osoby która wygenerowała token.'
    )
    contextIdentifier: Optional[TokenContextIdentifierTypeIdentifier] = Field(
        None,
        description='Identyfikator kontekstu, w którym został wygenerowany token i do którego daje dostęp.',
    )
    description: Optional[str] = Field(None, description='Opis tokena.')
    requestedPermissions: Optional[List[TokenPermissionType]] = Field(
        None, description='Uprawnienia przypisane tokenowi.'
    )
    dateCreated: Optional[AwareDatetime] = Field(
        None, description='Data i czas utworzenia tokena.'
    )
    lastUseDate: Optional[AwareDatetime] = Field(
        None, description='Data ostatniego użycia tokena.'
    )
    status: Optional[AuthenticationTokenStatus] = Field(
        None,
        description='Status tokena.\n| Wartość | Opis |\n| --- | --- |\n| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |\n| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |\n| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |\n| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |\n| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |\n',
    )
    statusDetails: Optional[List[str]] = Field(
        None,
        description='Dodatkowe informacje na temat statusu, zwracane w przypadku błędów.',
    )


class UpoPageResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(..., description='Numer referencyjny strony UPO.')
    downloadUrl: AnyUrl = Field(..., description='Adres do pobrania strony UPO.')


class UpoResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    pages: List[UpoPageResponse] = Field(..., description='Lista stron UPO.')


class AuthenticationContextIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: AuthenticationContextIdentifierType = Field(
        ..., description='Typ identyfikatora'
    )
    value: str = Field(..., description='Wartość identyfikatora')


class AuthenticationInitResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(
        ..., description='Numer referencyjny operacji uwierzytelnienia.'
    )
    authenticationToken: TokenInfo = Field(
        ..., description='Token operacji uwierzytelnienia.'
    )


class AuthenticationListItem(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia operacji uwierzytelnienia.'
    )
    authenticationMethod: AuthenticationMethod = Field(
        ...,
        description='Użyta metoda uwierzytelnienia.\n| Wartość | Opis |\n| --- | --- |\n| Token | Token KSeF. |\n| TrustedProfile | Profil Zaufany. |\n| InternalCertificate | Certyfikat KSeF. |\n| QualifiedSignature | Podpis kwalifikowany. |\n| QualifiedSeal | Pieczęć kwalifikowana. |\n| PersonalSignature | Podpis osobisty. |\n| PeppolSignature | Podpis dostawcy uslug Peppol. |\n',
    )
    status: StatusInfo = Field(
        ...,
        description='Informacje o aktualnym statusie.\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Uwierzytelnianie w toku | - |\n| 200 | Uwierzytelnianie zakończone sukcesem | - |\n| 415 | Uwierzytelnianie zakończone niepowodzeniem | Brak przypisanych uprawnień |\n| 425 | Uwierzytelnienie unieważnione  | Uwierzytelnienie i powiązane refresh tokeny zostały unieważnione przez użytkownika |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Nieprawidłowy token |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Nieprawidłowy czas tokena |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Token unieważniony |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Token nieaktywny |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Nieważny certyfikat |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Błąd weryfikacji łańcucha certyfikatów |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Niezaufany łańcuch certyfikatów |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Certyfikat odwołany |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Niepoprawny certyfikat |\n| 500 | Nieznany błąd | - |',
    )
    isTokenRedeemed: Optional[bool] = Field(
        None,
        description='Czy został już wydany refresh token powiązany z danym uwierzytelnieniem.',
    )
    lastTokenRefreshDate: Optional[AwareDatetime] = Field(
        None, description='Data ostatniego odświeżenia tokena.'
    )
    refreshTokenValidUntil: Optional[AwareDatetime] = Field(
        None,
        description='Termin ważności refresh tokena (o ile nie zostanie wcześniej unieważniony).',
    )
    referenceNumber: str = Field(
        ..., description='Numer referencyjny operacji uwierzytelnienia.'
    )
    isCurrent: Optional[bool] = Field(
        None, description='Czy sesja jest powiązana z aktualnie używanym tokenem.'
    )


class AuthenticationListResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    continuationToken: Optional[str] = Field(
        None,
        description='Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.',
    )
    items: List[AuthenticationListItem] = Field(
        ..., description='Lista sesji uwierzytelniania.'
    )


class AuthenticationOperationStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia operacji uwierzytelnienia.'
    )
    authenticationMethod: AuthenticationMethod = Field(
        ...,
        description='Użyta metoda uwierzytelnienia.\n| Wartość | Opis |\n| --- | --- |\n| Token | Token KSeF. |\n| TrustedProfile | Profil Zaufany. |\n| InternalCertificate | Certyfikat KSeF. |\n| QualifiedSignature | Podpis kwalifikowany. |\n| QualifiedSeal | Pieczęć kwalifikowana. |\n| PersonalSignature | Podpis osobisty. |\n| PeppolSignature | Podpis dostawcy uslug Peppol. |\n',
    )
    status: StatusInfo = Field(
        ...,
        description='Informacje o aktualnym statusie.\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Uwierzytelnianie w toku | - |\n| 200 | Uwierzytelnianie zakończone sukcesem | - |\n| 415 | Uwierzytelnianie zakończone niepowodzeniem | Brak przypisanych uprawnień |\n| 425 | Uwierzytelnienie unieważnione  | Uwierzytelnienie i powiązane refresh tokeny zostały unieważnione przez użytkownika |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Nieprawidłowy token |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Nieprawidłowy czas tokena |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Token unieważniony |\n| 450 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędnego tokenu | Token nieaktywny |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Nieważny certyfikat |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Błąd weryfikacji łańcucha certyfikatów |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Niezaufany łańcuch certyfikatów |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Certyfikat odwołany |\n| 460 | Uwierzytelnianie zakończone niepowodzeniem z powodu błędu certyfikatu | Niepoprawny certyfikat |\n| 500 | Nieznany błąd | - |',
    )
    isTokenRedeemed: Optional[bool] = Field(
        None,
        description='Czy został już wydany refresh token powiązany z danym uwierzytelnieniem.',
    )
    lastTokenRefreshDate: Optional[AwareDatetime] = Field(
        None, description='Data ostatniego odświeżenia tokena.'
    )
    refreshTokenValidUntil: Optional[AwareDatetime] = Field(
        None,
        description='Termin ważności refresh tokena (o ile nie zostanie wcześniej unieważniony).',
    )


class AuthenticationTokenRefreshResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    accessToken: TokenInfo = Field(
        ...,
        description='Token dostępu, którego należy używać w wywołaniach chronionych zasobów API.',
    )


class AuthenticationTokensResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    accessToken: TokenInfo = Field(..., description='Token dostępu.')
    refreshToken: TokenInfo = Field(
        ...,
        description='Token umożliwiający odświeżenie tokenu dostępu.\n> Więcej informacji:\n> - [Odświeżanie tokena](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#od%C5%9Bwie%C5%BCenie-tokena-accesstoken)',
    )


class BatchFileInfo(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    fileSize: conint(ge=1, le=5368709120) = Field(
        ...,
        description='Rozmiar pliku paczki w bajtach. Maksymalny rozmiar paczki to 5GiB (5 368 709 120 bajtów).',
    )
    fileHash: str = Field(
        ..., description='Skrót SHA256 pliku paczki, zakodowany w formacie Base64.'
    )
    fileParts: List[BatchFilePartInfo] = Field(
        ...,
        description='Informacje o częściach pliku paczki. Maksymalna liczba części to 50.',
    )


class CertificateEnrollmentStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    requestDate: AwareDatetime = Field(
        ..., description='Data złożenia wniosku certyfikacyjnego.'
    )
    status: StatusInfo = Field(
        ...,
        description='Informacje o aktualnym statusie.\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Wniosek przyjęty do realizacji | - |\n| 200 | Wniosek obsłużony (certyfikat wygenerowany) | - |\n| 400 | Wniosek odrzucony | Klucz publiczny został już certyfikowany przez inny podmiot. |\n| 400 | Wniosek odrzucony | Osiągnięto dopuszczalny limit posiadanych certyfikatów. |\n| 500 | Nieznany błąd | - |',
    )
    certificateSerialNumber: Optional[str] = Field(
        None,
        description='Numer seryjny wygenerowanego certyfikatu (w formacie szesnastkowym). \nZwracany w przypadku prawidłowego przeprocesowania wniosku certyfikacyjnego.',
    )


class CertificateSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: CertificateSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EffectiveContextLimits(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    onlineSession: OnlineSessionEffectiveContextLimits = Field(
        ..., description='Limity dla sesji interaktywnych.'
    )
    batchSession: BatchSessionEffectiveContextLimits = Field(
        ..., description='Limity dla sesji wsadowych.'
    )


class EffectiveSubjectLimits(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    enrollment: Optional[EnrollmentEffectiveSubjectLimits] = None
    certificate: Optional[CertificateEffectiveSubjectLimits] = None


class EnrollCertificateRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificateName: str = Field(..., description='Nazwa własna certyfikatu.')
    certificateType: KsefCertificateType = Field(
        ...,
        description='Typ certyfikatu.\n| Wartość | Opis |\n| --- | --- |\n| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |\n| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |\n',
    )
    csr: str = Field(
        ...,
        description='Wniosek certyfikacyjny PKCS#10 (CSR) w formacie DER zakodowany w Base64.',
    )
    validFrom: Optional[AwareDatetime] = Field(
        None,
        description='Data rozpoczęcia ważności certyfikatu.\nJeśli nie zostanie podana, certyfikat będzie ważny od momentu jego wystawienia.',
    )


class EntityAuthorizationPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityAuthorizationPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EntityAuthorizationsAuthorIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityAuthorizationsAuthorIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EntityAuthorizationsAuthorizedEntityIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityAuthorizationsAuthorizedEntityIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EntityAuthorizationsAuthorizingEntityIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityAuthorizationsAuthorizingEntityIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EntityPermission(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityPermissionType = Field(
        ..., description='Możliwe uprawnienia do nadania.'
    )
    canDelegate: Optional[bool] = Field(
        None,
        description='Flaga pozwalająca na pośrednie przekazywanie danego uprawnienia',
    )


class EntityPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EntityPermissionsSubordinateEntityIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityPermissionsSubordinateEntityIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EntityRolesParentEntityIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EntityRolesParentEntityIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EuEntityAdministrationPermissionsContextIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EuEntityAdministrationPermissionsContextIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EuEntityAdministrationPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EuEntityAdministrationPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EuEntityPermissionsAuthorIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EuEntityPermissionsAuthorIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class EuEntityPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: EuEntityPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class GenerateTokenRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    permissions: Optional[List[TokenPermissionType]] = Field(
        None, description='Uprawnienia przypisane tokenowi.'
    )
    description: Optional[str] = Field(None, description='Opis tokena.')


class IndirectPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: IndirectPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class IndirectPermissionsTargetIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: IndirectPermissionsTargetIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: Optional[str] = Field(
        None,
        description='Wartość identyfikatora. W przypadku typu AllPartners należy pozostawić puste. W pozostałych przypadkach pole jest wymagane.',
    )


class InitTokenAuthenticationRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    challenge: str = Field(..., description='Wygenerowany wcześniej challenge.')
    contextIdentifier: AuthenticationContextIdentifier = Field(
        ...,
        description='Indentyfikator kontekstu do którego następuje uwierzytelnienie.',
    )
    encryptedToken: str = Field(
        ...,
        description="Zaszyfrowany token wraz z timestampem z challenge'a, w formacie `token|timestamp`.",
    )
    authorizationPolicy: Optional[AuthorizationPolicy] = Field(
        None,
        description='Polityka autoryzacji żądań przy każdym użyciu tokena dostępu.',
    )


class InvoiceMetadataBuyer(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    identifier: InvoiceMetadataBuyerIdentifier = Field(
        ..., description='Identyfikator nabywcy.'
    )
    name: Optional[str] = Field(None, description='Nazwa nabywcy.')


class InvoiceMetadataThirdSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: ThirdSubjectIdentifierType = Field(
        ...,
        description='Typ identyfikatora podmiotu trzeciego.\n| Wartość | Opis |\n| --- | --- |\n| Nip | Nip |\n| InternalId | Identyfikator wewnętrzny |\n| VatUe | VAT UE |\n| Other | Inny identyfikator |\n| None | Brak identyfikatora podmiotu trzeciego |\n',
    )
    value: Optional[str] = Field(
        None, description='Wartość identyfikatora podmiotu trzeciego.'
    )


class InvoicePackage(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    invoiceCount: conint(ge=0, le=10000) = Field(
        ..., description='Łączna liczba faktur w paczce.'
    )
    size: conint(ge=0, le=1073741824) = Field(
        ...,
        description='Rozmiar paczki w bajtach. Maksymalny rozmiar paczki to 1 GiB (1 073 741 824 bajtów).',
    )
    parts: List[InvoicePackagePart] = Field(
        ...,
        description='Lista dostępnych części paczki do pobrania. Każda część jest zaszyfrowana algorytmem AES-256-CBC z dopełnieniem PKCS#7, przy użyciu klucza symetrycznego przekazanego podczas inicjowania eksportu. Wyniki sortowane są rosnąco według typu daty przekazanej w `DateRange` przy inicjalizacji.',
    )
    isTruncated: bool = Field(
        ...,
        description='Określa, czy wynik eksportu został ucięty z powodu przekroczenia limitu liczby faktur lub wielkości paczki.',
    )
    lastIssueDate: Optional[date] = Field(
        None,
        description='Data wystawienia ostatniej faktury ujętej w paczce.\nPole występuje wyłącznie wtedy, gdy paczka została ucięta i eksport był filtrowany po typie daty `Issue`.',
    )
    lastInvoicingDate: Optional[AwareDatetime] = Field(
        None,
        description='Data przyjęcia ostatniej faktury ujętej w paczce.\nPole występuje wyłącznie wtedy, gdy paczka została ucięta i eksport był filtrowany po typie daty `Invoicing`.',
    )
    lastPermanentStorageDate: Optional[AwareDatetime] = Field(
        None,
        description='Data trwałego zapisu ostatniej faktury ujętej w paczce.\nPole występuje wyłącznie wtedy, gdy paczka została ucięta i eksport był filtrowany po typie daty `PermanentStorage`.',
    )


class InvoiceQueryDateRange(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    dateType: InvoiceQueryDateType = Field(
        ...,
        description='Typ daty, według której ma być zastosowany zakres.\n| Wartość | Opis |\n| --- | --- |\n| Issue | Data wystawienia faktury. |\n| Invoicing | Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania). |\n| PermanentStorage | Data trwałego zapisu faktury w repozytorium systemu KSeF. |\n',
    )
    from_: AwareDatetime = Field(
        ..., alias='from', description='Data początkowa zakresu.'
    )
    to: Optional[AwareDatetime] = Field(
        None,
        description='Data końcowa zakresu. Jeśli nie zostanie podana, przyjmowana jest bieżąca data i czas w UTC.',
    )


class InvoiceQueryFilters(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectType: InvoiceQuerySubjectType = Field(
        ...,
        description='Typ podmiotu, którego dotyczą kryteria filtrowania metadanych faktur.\nOkreśla kontekst, w jakim przeszukiwane są dane.\n| Wartość | Opis |\n| --- | --- |\n| Subject1 | Podmiot 1 |\n| Subject2 | Podmiot 2 |\n| Subject3 | Podmiot 3 |\n| SubjectAuthorized | Podmiot upoważniony |\n',
    )
    dateRange: InvoiceQueryDateRange = Field(
        ...,
        description='Typ i zakres dat, według którego mają być filtrowane faktury. Dozwolony maksymalny okres wynosi 2 lata.',
    )
    ksefNumber: Optional[str] = Field(None, description='Numer KSeF faktury.')
    invoiceNumber: Optional[str] = Field(
        None, description='Numer faktury nadany przez wystawcę.'
    )
    amount: Optional[InvoiceQueryAmount] = Field(
        None, description='Filtr kwotowy – brutto, netto lub VAT (z wartością).'
    )
    sellerNip: Optional[str] = Field(None, description='Nip sprzedawcy.')
    buyerIdentifier: Optional[InvoiceQueryBuyerIdentifier] = Field(
        None, description='Identyfikator nabywcy.'
    )
    currencyCodes: Optional[List[CurrencyCode]] = Field(None, description='Kody walut.')
    invoicingMode: Optional[InvoicingMode] = Field(
        None, description='Tryb wystawienia faktury: online lub offline.'
    )
    isSelfInvoicing: Optional[bool] = Field(
        None, description='Czy faktura została wystawiona w trybie samofakturowania.'
    )
    formType: Optional[InvoiceQueryFormType] = Field(
        None,
        description='Typ dokumentu.\n| Wartość | Opis |\n| --- | --- |\n| FA | Faktura VAT |\n| PEF | Faktura PEF |\n| RR | Faktura RR |\n',
    )
    invoiceTypes: Optional[List[InvoiceType]] = Field(
        None,
        description='Rodzaje faktur.\n| Wartość | Opis |\n| --- | --- |\n| Vat | (FA) Podstawowa |\n| Zal | (FA) Zaliczkowa |\n| Kor | (FA) Korygująca |\n| Roz | (FA) Rozliczeniowa |\n| Upr | (FA) Uproszczona |\n| KorZal | (FA) Korygująca fakturę zaliczkową |\n| KorRoz | (FA) Korygująca fakturę rozliczeniową |\n| VatPef | (PEF) Podstawowowa |\n| VatPefSp | (PEF) Specjalizowana |\n| KorPef | (PEF) Korygująca |\n| VatRr | (RR) Podstawowa |\n| KorVatRr | (RR) Korygująca |\n',
    )
    hasAttachment: Optional[bool] = Field(None, description='Czy faktura ma załącznik.')


class OpenBatchSessionRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    formCode: FormCode = Field(
        ...,
        description='Schemat faktur wysyłanych w ramach sesji.\n\nObsługiwane schematy:\n| SystemCode | SchemaVersion | Value |\n| --- | --- | --- |\n| FA (2) | 1-0E | FA |\n| FA (3) | 1-0E | FA |\n',
    )
    batchFile: BatchFileInfo = Field(
        ..., description='Informacje o przesyłanej paczce faktur.'
    )
    encryption: EncryptionInfo = Field(
        ...,
        description='Symetryczny klucz szyfrujący plik paczki, zaszyfrowany kluczem publicznym Ministerstwa Finansów.',
    )
    offlineMode: Optional[bool] = Field(
        False,
        description='Określa, czy podatnik deklaruje tryb fakurowania "offline" dla dokumentów przesyłanych w sesji wsadowej.',
    )


class OpenBatchSessionResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(..., description='Numer referencyjny sesji.')
    partUploadRequests: List[PartUploadRequest] = Field(
        ...,
        description='Dane wymagane do poprawnego przesłania poszczególnych części pliku paczki faktur.',
    )


class PermissionsOperationStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    status: StatusInfo = Field(
        ...,
        description='Informacje o aktualnym statusie.\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Operacja przyjęta do realizacji | - |\n| 200 | Operacja zakończona sukcesem | - |\n| 400 | Operacja zakończona niepowodzeniem | - |\n| 410 | Podane identyfikatory są niezgodne lub pozostają w niewłaściwej relacji | - |\n| 420 | Użyte poświadczenia nie mają uprawnień do wykonania tej operacji | - |\n| 430 | Kontekst identyfikatora nie odpowiada wymaganej roli lub uprawnieniom | - |\n| 440 | Operacja niedozwolona dla wskazanych powiązań identyfikatorów | - |\n| 450 | Operacja niedozwolona dla wskazanego identyfikatora lub jego typu | - |\n| 500 | Nieznany błąd | - |',
    )


class PersonPermissionsAuthorIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonPermissionsAuthorIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: Optional[str] = Field(
        None,
        description='Wartość identyfikatora. W przypadku typu System należy pozostawić puste. W pozostałych przypadkach pole jest wymagane.',
    )


class PersonPermissionsAuthorizedIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonPermissionsAuthorizedIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class PersonPermissionsContextIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonPermissionsContextIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class PersonPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class PersonPermissionsTargetIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonPermissionsTargetIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: Optional[str] = Field(
        None,
        description='Wartość identyfikatora. W przypadku typu AllPartners należy pozostawić puste. W pozostałych przypadkach pole jest wymagane.',
    )


class PersonalPermissionsAuthorizedIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonalPermissionsAuthorizedIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class PersonalPermissionsContextIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonalPermissionsContextIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class PersonalPermissionsTargetIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: PersonalPermissionsTargetIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: Optional[str] = Field(
        None,
        description='Wartość identyfikatora. W przypadku typu AllPartners należy pozostawić puste. W pozostałych przypadkach pole jest wymagane.',
    )


class PublicKeyCertificate(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificate: str = Field(
        ...,
        description='Certyfikat klucza publicznego w formacie DER zakodowany w Base64.',
    )
    validFrom: AwareDatetime = Field(
        ..., description='Data początku obowiązywania certyfikatu.'
    )
    validTo: AwareDatetime = Field(
        ..., description='Data końca obowiązywania certyfikatu.'
    )
    usage: List[PublicKeyCertificateUsage] = Field(
        ...,
        description='Operacje do których może być używany certyfikat.\n| Wartość | Opis |\n| --- | --- |\n| KsefTokenEncryption | Szyfrowanie tokenów KSeF przesyłanych w trakcie procesu uwierzytelniania. |\n| SymmetricKeyEncryption | Szyfrowanie klucza symetrycznego wykorzystywanego do szyfrowania przesyłanych faktur. |\n',
    )


class QueryTokensResponseItem(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: Optional[str] = Field(
        None, description='Numer referencyjny tokena.'
    )
    authorIdentifier: Optional[TokenAuthorIdentifierTypeIdentifier] = Field(
        None, description='Identyfikator osoby która wygenerowała token.'
    )
    contextIdentifier: Optional[TokenContextIdentifierTypeIdentifier] = Field(
        None,
        description='Identyfikator kontekstu, w którym został wygenerowany token i do którego daje dostęp.',
    )
    description: Optional[str] = Field(None, description='Opis tokena.')
    requestedPermissions: Optional[List[TokenPermissionType]] = Field(
        None, description='Uprawnienia przypisane tokenowi.'
    )
    dateCreated: Optional[AwareDatetime] = Field(
        None, description='Data i czas utworzenia tokena.'
    )
    lastUseDate: Optional[AwareDatetime] = Field(
        None, description='Data ostatniego użycia tokena.'
    )
    status: Optional[AuthenticationTokenStatus] = Field(
        None,
        description='Status tokena.\n| Wartość | Opis |\n| --- | --- |\n| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |\n| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |\n| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |\n| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |\n| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |\n',
    )
    statusDetails: Optional[List[str]] = Field(
        None,
        description='Dodatkowe informacje na temat statusu, zwracane w przypadku błędów.',
    )


class SessionInvoiceStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    ordinalNumber: conint(ge=1) = Field(
        ..., description='Numer sekwencyjny faktury w ramach sesji.'
    )
    invoiceNumber: Optional[str] = Field(None, description='Numer faktury.')
    ksefNumber: Optional[str] = Field(None, description='Numer KSeF.')
    referenceNumber: Optional[str] = Field(
        None, description='Numer referencyjny faktury.'
    )
    invoiceHash: Optional[str] = Field(
        None, description='Skrót SHA256 faktury, zakodowany w formacie Base64.'
    )
    invoiceFileName: Optional[str] = Field(
        None,
        description='Nazwa pliku faktury (zwracana dla faktur wysyłanych wsadowo).',
    )
    acquisitionDate: Optional[AwareDatetime] = Field(
        None, description='Data nadania numeru KSeF.'
    )
    invoicingDate: AwareDatetime = Field(
        ...,
        description='Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania).',
    )
    permanentStorageDate: Optional[AwareDatetime] = Field(
        None, description='Data trwałego zapisu faktury w repozytorium systemu KSeF.'
    )
    upoDownloadUrl: Optional[AnyUrl] = Field(None, description='Adres do pobrania UPO.')
    invoicingMode: Optional[InvoicingMode] = Field(
        None, description='Tryb fakturowania (online/offline).'
    )
    status: StatusInfo = Field(
        ...,
        description='Status faktury.\n\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Faktura przyjęta do dalszego przetwarzania | - |\n| 150 | Trwa przetwarzanie | - |\n| 200 | Sukces | - |\n| 405 | Przetwarzanie anulowane | - |\n| 410 | Nieprawidłowy zakres uprawnień | - |\n| 415 | Brak możliwości wysyłania faktury z załącznikiem | - |\n| 430 | Błąd weryfikacji pliku faktury | - |\n| 435 | Błąd odszyfrowania pliku | - |\n| 440 | Duplikat faktury | - |\n| 450 | Błąd weryfikacji semantyki dokumentu faktury | - |\n| 500 | Nieznany błąd ({statusCode}) | - |',
    )


class SessionInvoicesResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    continuationToken: Optional[str] = Field(
        None,
        description='Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.',
    )
    invoices: List[SessionInvoiceStatusResponse] = Field(
        ..., description='Lista pobranych faktur.'
    )


class SessionStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    status: StatusInfo = Field(
        ...,
        description='Informacje o aktualnym statusie.\n            \nSesja wsadowa:\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Sesja wsadowa rozpoczęta | - |\n| 150 | Trwa przetwarzanie | - |\n| 200 | Sesja wsadowa przetworzona pomyślnie | - |\n| 405 | Błąd weryfikacji poprawności dostarczonych elementów paczki | - |\n| 415 | Błąd odszyfrowania dostarczonego klucza | - |\n| 420 | Przekroczony limit faktur w sesji | - |\n| 430 | Błąd dekompresji pierwotnego archiwum | - |\n| 435 | Błąd odszyfrowania zaszyfrowanych części archiwum | - |\n| 440 | Sesja anulowana, przekroczono czas wysyłki | - |\n| 445 | Błąd weryfikacji, brak poprawnych faktur | - |\n| 500 | Nieznany błąd ({statusCode}) | - |\n\nSesja interaktywna:\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Sesja interaktywna otwarta | - |\n| 170 | Sesja interaktywna zamknięta | - |\n| 200 | Sesja interaktywna przetworzona pomyślnie | - |\n| 415 | Błąd odszyfrowania dostarczonego klucza | - |\n| 440 | Sesja anulowana, nie przesłano faktur | - |\n| 445 | Błąd weryfikacji, brak poprawnych faktur | - |\n| * | description missing | - |',
    )
    validUntil: Optional[AwareDatetime] = Field(
        None,
        description='Termin ważności sesji. Po jego upływie sesja zostanie automatycznie zamknięta.',
    )
    upo: Optional[UpoResponse] = Field(
        None,
        description='Informacja o UPO sesyjnym, zwracana gdy sesja została zamknięta i UPO zostało wygenerowane.',
    )
    invoiceCount: Optional[conint(ge=0)] = Field(
        None, description='Liczba przyjętych faktur w ramach sesji.'
    )
    successfulInvoiceCount: Optional[conint(ge=0)] = Field(
        None, description='Liczba faktur przeprocesowanych w ramach sesji z sukcesem .'
    )
    failedInvoiceCount: Optional[conint(ge=0)] = Field(
        None, description='Liczba faktur przeprocesowanych w ramach sesji z błędem.'
    )


class SessionsQueryResponseItem(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    referenceNumber: str = Field(..., description='Numer referencyjny sesji.')
    status: StatusInfo = Field(..., description='Status sesji.')
    dateCreated: AwareDatetime = Field(..., description='Data utworzenia sesji.')
    dateUpdated: AwareDatetime = Field(
        ..., description='Data ostatniej aktywności w ramach sesji.'
    )
    validUntil: Optional[AwareDatetime] = Field(
        None,
        description='Termin ważności sesji. Po jego upływie sesja interaktywna zostanie automatycznie zamknięta.',
    )
    totalInvoiceCount: conint(ge=0) = Field(
        ...,
        description='Łączna liczba faktur (uwzględnia również te w trakcie przetwarzania).',
    )
    successfulInvoiceCount: conint(ge=0) = Field(
        ..., description='Liczba poprawnie przetworzonych faktur.'
    )
    failedInvoiceCount: conint(ge=0) = Field(
        ..., description='Liczba błędnie przetworzonych faktur.'
    )


class SetSubjectLimitsRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifierType: Optional[SubjectIdentifierType] = None
    enrollment: Optional[EnrollmentSubjectLimitsOverride] = None
    certificate: Optional[CertificateSubjectLimitsOverride] = None


class SubjectCreateRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectNip: str
    subjectType: SubjectType
    subunits: Optional[List[Subunit]] = None
    description: str
    createdDate: Optional[AwareDatetime] = None


class SubordinateEntityRolesQueryRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subordinateEntityIdentifier: Optional[
        EntityPermissionsSubordinateEntityIdentifier
    ] = Field(
        None,
        description='Identyfikator podmiotu podrzędnego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )


class SubordinateRoleSubordinateEntityIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: SubordinateRoleSubordinateEntityIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class SubunitPermissionsAuthorIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: SubunitPermissionsAuthorIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class SubunitPermissionsAuthorizedIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: SubunitPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class SubunitPermissionsContextIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: SubunitPermissionsContextIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class SubunitPermissionsSubjectIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: SubunitPermissionsSubjectIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class SubunitPermissionsSubunitIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: SubunitPermissionsSubunitIdentifierType = Field(
        ..., description='Typ identyfikatora.'
    )
    value: str = Field(..., description='Wartość identyfikatora.')


class TestDataAuthorizedIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: TestDataAuthorizedIdentifierType
    value: str


class TestDataContextIdentifier(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    type: TestDataContextIdentifierType
    value: str


class TestDataPermission(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    description: str
    permissionType: TestDataPermissionType


class TestDataPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    contextIdentifier: TestDataContextIdentifier
    authorizedIdentifier: TestDataAuthorizedIdentifier
    permissions: List[TestDataPermission]


class TestDataPermissionsRevokeRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    contextIdentifier: TestDataContextIdentifier
    authorizedIdentifier: TestDataAuthorizedIdentifier


class CertificateListItem(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificateSerialNumber: str = Field(
        ..., description='Numer seryjny certyfikatu (w formacie szesnastkowym).'
    )
    name: str = Field(..., description='Nazwa własna certyfikatu.')
    type: KsefCertificateType = Field(
        ...,
        description='Typ certyfikatu.\n| Wartość | Opis |\n| --- | --- |\n| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |\n| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |\n',
    )
    commonName: str = Field(
        ...,
        description='Nazwa powszechna (CN) podmiotu, dla którego wystawiono certyfikat.',
    )
    status: CertificateListItemStatus = Field(
        ...,
        description='Status certyfikatu.\n| Wartość | Opis |\n| --- | --- |\n| Active | Certyfikat jest aktywny i może zostać użyty do uwierzytelnienia lub realizacji operacji w trybie offline (w zależności od typu certyfikatu). |\n| Blocked | Certyfikat został zablokowany i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline.            Status przejściowy do czasu zakończenia procesu unieważniania. |\n| Revoked | Certyfikat został unieważniony i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |\n| Expired | Certyfikat wygasł i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |\n',
    )
    subjectIdentifier: CertificateSubjectIdentifier = Field(
        ..., description='Identyfikator podmiotu, dla którego wystawiono certyfikat.'
    )
    validFrom: AwareDatetime = Field(
        ..., description='Data rozpoczęcia ważności certyfikatu.'
    )
    validTo: AwareDatetime = Field(..., description='Data wygaśnięcia certyfikatu.')
    lastUseDate: Optional[AwareDatetime] = Field(
        None, description='Data ostatniego użycia certyfikatu.'
    )


class EntityAuthorizationGrant(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    id: str = Field(..., description='Identyfikator uprawnienia.')
    authorIdentifier: Optional[EntityAuthorizationsAuthorIdentifier] = Field(
        None,
        description='Identyfikator osoby nadającej uprawnienie.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    authorizedEntityIdentifier: EntityAuthorizationsAuthorizedEntityIdentifier = Field(
        ...,
        description='Identyfikator podmiotu uprawnionego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| PeppolId | Identyfikator dostawcy usług Peppol |',
    )
    authorizingEntityIdentifier: EntityAuthorizationsAuthorizingEntityIdentifier = (
        Field(
            ...,
            description='Identyfikator podmiotu uprawniającego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
        )
    )
    authorizationScope: InvoicePermissionType = Field(..., description='Uprawnienie.')
    description: str = Field(..., description='Opis uprawnienia.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania uprawnienia.'
    )


class EntityAuthorizationPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: EntityAuthorizationPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator podmiotu.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    permission: EntityAuthorizationPermissionType = Field(
        ..., description='Nadawane uprawnienie o charakterze upoważnienia.'
    )
    description: str = Field(..., description='Opis nadawanego uprawnienia.')


class EntityAuthorizationPermissionsQueryRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    authorizingIdentifier: Optional[EntityAuthorizationsAuthorizingEntityIdentifier] = (
        Field(
            None,
            description='Identyfikator podmiotu uprawniającego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
        )
    )
    authorizedIdentifier: Optional[EntityAuthorizationsAuthorizedEntityIdentifier] = (
        Field(
            None,
            description='Identyfikator podmiotu uprawnionego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| PeppolId | Identyfikator dostawcy usług Peppol |',
        )
    )
    queryType: QueryType = Field(
        ...,
        description='Typ zapytania.\n| Type | Value |\n| --- | --- |\n| Granted | Uprawnienia nadane innym podmiotom |\n| Received | Uprawnienia otrzymane od innych podmiotów |',
    )
    permissionTypes: Optional[List[InvoicePermissionType]] = Field(
        None, description='Możliwe uprawnienia do filtrowania.'
    )


class EntityPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: EntityPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator podmiotu.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    permissions: List[EntityPermission] = Field(
        ...,
        description='Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.',
    )
    description: str = Field(..., description='Opis nadawanych uprawnień.')


class EntityRole(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    parentEntityIdentifier: Optional[EntityRolesParentEntityIdentifier] = Field(
        None,
        description='Identyfikator podmiotu nadrzędnego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    role: EntityRoleType = Field(..., description='Rola.')
    description: str = Field(..., description='Opis.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania roli.'
    )


class EuEntityAdministrationPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: EuEntityAdministrationPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator podmiotu uprawnionego.\n| Type | Value |\n| --- | --- |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    contextIdentifier: EuEntityAdministrationPermissionsContextIdentifier = Field(
        ...,
        description='Identyfikator zlożony z podmiotu polskiego i podmiotu unijnego.\n| Type | Value |\n| --- | --- |\n| NipVatUe | Dwuczłonowy identyfikator składający się z numeru NIP i numeru VAT-UE: `{nip}-{vat_ue}` |',
    )
    description: str = Field(..., description='Opis nadawanych uprawnień.')
    euEntityName: str = Field(..., description='Nazwa podmiotu unijnego.')


class EuEntityPermission(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    id: str = Field(..., description='Identyfikator uprawnienia.')
    authorIdentifier: EuEntityPermissionsAuthorIdentifier = Field(
        ...,
        description='Identyfikator uprawniającego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    vatUeIdentifier: str = Field(..., description='Identyfikator podmiotu unijnego.')
    euEntityName: str = Field(..., description='Nazwa podmiotu unijnego.')
    authorizedFingerprintIdentifier: str = Field(
        ..., description='Uprawniony odcisk palca certyfikatu.'
    )
    permissionScope: EuEntityPermissionsQueryPermissionType = Field(
        ..., description='Uprawnienie.'
    )
    description: str = Field(..., description='Opis uprawnienia.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania uprawnienia.'
    )


class EuEntityPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: EuEntityPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator podmiotu.\n| Type | Value |\n| --- | --- |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    permissions: List[EuEntityPermissionType] = Field(
        ...,
        description='Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.',
    )
    description: str = Field(..., description='Opis nadawanych uprawnień.')


class IndirectPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: IndirectPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator osoby fizycznej.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    targetIdentifier: Optional[IndirectPermissionsTargetIdentifier] = Field(
        None,
        description='Identyfikator podmiotu, w którego kontekście chcemy pośrednio nadać uprawnienia.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| AllPartners | Identyfikator oznaczający, że uprawnienie nadane w sposób pośredni jest typu generalnego |',
    )
    permissions: List[IndirectPermissionType] = Field(
        ...,
        description='Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.',
    )
    description: str = Field(..., description='Opis nadawanych uprawnień.')


class InvoiceExportRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    encryption: EncryptionInfo = Field(
        ..., description='Informacje wymagane do zaszyfrowania wyniku zapytania.'
    )
    filters: InvoiceQueryFilters = Field(
        ..., description='Zestaw filtrów do wyszukiwania faktur.'
    )


class InvoiceExportStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    status: StatusInfo = Field(
        ...,
        description='Status eksportu.\n\n| Code | Description | Details |\n| --- | --- | --- |\n| 100 | Eksport faktur w toku | - |\n| 200 | Eksport faktur zakończony sukcesem | - |\n| 415 | Błąd odszyfrowania dostarczonego klucza  | - |\n| 500 | Nieznany błąd ({statusCode}) | - |',
    )
    completedDate: Optional[AwareDatetime] = Field(
        None, description='Data zakończenia przetwarzania żądania.'
    )
    package: Optional[InvoicePackage] = Field(
        None, description='Dane paczki faktur przygotowanej do pobrania.'
    )


class InvoiceMetadataThirdSubject(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    identifier: InvoiceMetadataThirdSubjectIdentifier = Field(
        ..., description='Identyfikator podmiotu trzeciego.'
    )
    name: Optional[str] = Field(None, description='Nazwa podmiotu trzeciego.')
    role: int = Field(..., description='Rola podmiotu trzeciego.')


class PersonPermission(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    id: str = Field(..., description='Identyfikator uprawnienia.')
    authorizedIdentifier: PersonPermissionsAuthorizedIdentifier = Field(
        ...,
        description='Identyfikator osoby lub podmiotu uprawnionego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    contextIdentifier: Optional[PersonPermissionsContextIdentifier] = Field(
        None,
        description='Identyfikator kontekstu uprawnienia (dla uprawnień nadanych administratorom jednostek podrzędnych).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |',
    )
    targetIdentifier: Optional[PersonPermissionsTargetIdentifier] = Field(
        None,
        description='Identyfikator podmiotu docelowego (dla uprawnień pośrednich).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| AllPartners | Identyfikator oznaczający, że uprawnienie nadane w sposób pośredni jest typu generalnego |',
    )
    authorIdentifier: PersonPermissionsAuthorIdentifier = Field(
        ...,
        description='Identyfikator osoby lub podmiotu nadającego uprawnienie.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |\n| System | Identyfikator systemowy KSeF |',
    )
    permissionScope: PersonPermissionScope = Field(..., description='Uprawnienie.')
    description: str = Field(..., description='Opis uprawnienia.')
    permissionState: PermissionState = Field(..., description='Stan uprawnienia.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania uprawnienia.'
    )
    canDelegate: bool = Field(
        ...,
        description='Informacja o możliwości dalszego nadawania uprawnienia w sposób pośredni.',
    )


class PersonPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: PersonPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator osoby fizycznej.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    permissions: List[PersonPermissionType] = Field(
        ...,
        description='Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.',
    )
    description: str = Field(..., description='Opis nadawanych uprawnień.')


class PersonPermissionsQueryRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    authorIdentifier: Optional[PersonPermissionsAuthorIdentifier] = Field(
        None,
        description='Identyfikator osoby lub podmiotu nadającego uprawnienie.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |\n| System | Identyfikator systemowy KSeF |',
    )
    authorizedIdentifier: Optional[PersonPermissionsAuthorizedIdentifier] = Field(
        None,
        description='Identyfikator osoby lub podmiotu uprawnionego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    contextIdentifier: Optional[PersonPermissionsContextIdentifier] = Field(
        None,
        description='Identyfikator kontekstu uprawnienia (dla uprawnień nadanych administratorom jednostek podrzędnych).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |',
    )
    targetIdentifier: Optional[PersonPermissionsTargetIdentifier] = Field(
        None,
        description='Identyfikator podmiotu docelowego (dla uprawnień pośrednich).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| AllPartners | Identyfikator oznaczający, że uprawnienie nadane w sposób pośredni jest typu generalnego |',
    )
    permissionTypes: Optional[List[PersonPermissionType]] = Field(
        None, description='Możliwe uprawnienia do filtrowania.'
    )
    permissionState: Optional[PermissionState] = Field(
        None,
        description='Stan uprawnienia. \n| Type | Value |\n| --- | --- |\n| Active | Uprawnienia aktywne |\n| Inactive | Uprawnienia nieaktywne, nadane w sposób poœredni |',
    )
    queryType: PersonPermissionsQueryType = Field(
        ...,
        description='Typ zapytania.\n| Type | Value |\n| --- | --- |\n| PermissionsInCurrentContext | Uprawnienia obowiązujące w aktualnym kontekście |\n| PermissionsGrantedInCurrentContext | Uprawnienia nadane w aktualnym kontekście |',
    )


class PersonalPermission(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    id: str = Field(..., description='Identyfikator uprawnienia.')
    contextIdentifier: Optional[PersonalPermissionsContextIdentifier] = Field(
        None,
        description='Identyfikator kontekstu uprawnienia (dla uprawnień nadanych podmiotom do obsługi faktur).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    authorizedIdentifier: Optional[PersonalPermissionsAuthorizedIdentifier] = Field(
        None,
        description='Identyfikator podmiotu uprawnionego, jeśli inny niż podmiot uwierzytelnienia.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    targetIdentifier: Optional[PersonalPermissionsTargetIdentifier] = Field(
        None,
        description='Identyfikator podmiotu docelowego (dla uprawnień pośrednich).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| AllPartners | Identyfikator oznaczający, że uprawnienie nadane w sposób pośredni jest typu generalnego |',
    )
    permissionScope: PersonalPermissionScope = Field(..., description='Uprawnienie.')
    description: str = Field(..., description='Opis uprawnienia.')
    permissionState: PermissionState = Field(..., description='Stan uprawnienia.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania uprawnienia.'
    )
    canDelegate: bool = Field(
        ...,
        description='Informacja o możliwości dalszego nadawania uprawnienia w sposób pośredni.',
    )


class PersonalPermissionsQueryRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    contextIdentifier: Optional[PersonalPermissionsContextIdentifier] = Field(
        None,
        description='Identyfikator kontekstu uprawnienia (dla uprawnień nadanych podmiotom do obsługi faktur).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    targetIdentifier: Optional[PersonalPermissionsTargetIdentifier] = Field(
        None,
        description='Identyfikator podmiotu docelowego (dla uprawnień pośrednich).\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| AllPartners | Identyfikator oznaczający, że uprawnienie nadane w sposób pośredni jest typu generalnego |',
    )
    permissionTypes: Optional[List[PersonalPermissionType]] = Field(
        None, description='Możliwe uprawnienia do filtrowania.'
    )
    permissionState: Optional[PermissionState] = Field(
        None,
        description='Stan uprawnienia. \n| Type | Value |\n| --- | --- |\n| Active | Uprawnienia aktywne |\n| Inactive | Uprawnienia nieaktywne, nadane w sposób pośredni |',
    )


class QueryCertificatesResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    certificates: List[CertificateListItem] = Field(
        ..., description='Lista certyfikatów spełniających kryteria wyszukiwania.'
    )
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryEntityAuthorizationPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    authorizationGrants: List[EntityAuthorizationGrant] = Field(
        ..., description='Lista uprawnień.'
    )
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryEntityRolesResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    roles: List[EntityRole] = Field(..., description='Lista ról.')
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryEuEntityPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    permissions: List[EuEntityPermission] = Field(..., description='Lista uprawnień.')
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryPersonPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    permissions: List[PersonPermission] = Field(..., description='Lista uprawnień.')
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryPersonalPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    permissions: List[PersonalPermission] = Field(..., description='Lista uprawnień.')
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QueryTokensResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    continuationToken: Optional[str] = Field(
        None,
        description='Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.',
    )
    tokens: List[QueryTokensResponseItem] = Field(
        ..., description='Lista tokenów uwierzytelniających.'
    )


class SessionsQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    continuationToken: Optional[str] = Field(
        None,
        description='Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.',
    )
    sessions: List[SessionsQueryResponseItem] = Field(..., description='Lista sesji.')


class SubordinateEntityRole(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subordinateEntityIdentifier: SubordinateRoleSubordinateEntityIdentifier = Field(
        ...,
        description='Identyfikator podmiotu podrzędnego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |',
    )
    role: SubordinateEntityRoleType = Field(..., description='Powiązanie.')
    description: str = Field(..., description='Opis.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania powiązania.'
    )


class SubunitPermission(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    id: str = Field(..., description='Identyfikator uprawnienia.')
    authorizedIdentifier: SubunitPermissionsAuthorizedIdentifier = Field(
        ...,
        description='Identyfikator uprawnionego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    subunitIdentifier: SubunitPermissionsSubunitIdentifier = Field(
        ...,
        description='Identyfikator jednostki lub podmiotu podrzędnego.\n| Type | Value |\n| --- | --- |\n| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |\n| Nip | 10 cyfrowy numer NIP |',
    )
    authorIdentifier: SubunitPermissionsAuthorIdentifier = Field(
        ...,
        description='Identyfikator uprawniającego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    permissionScope: SubunitPermissionScope = Field(..., description='Uprawnienie.')
    description: str = Field(..., description='Opis uprawnienia.')
    subunitName: Optional[str] = Field(None, description='Nazwa jednostki podrzędnej.')
    startDate: AwareDatetime = Field(
        ..., description='Data rozpoczęcia obowiązywania uprawnienia.'
    )


class SubunitPermissionsGrantRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subjectIdentifier: SubunitPermissionsSubjectIdentifier = Field(
        ...,
        description='Identyfikator podmiotu lub osoby fizycznej.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| Pesel | 11 cyfrowy numer PESEL |\n| Fingerprint | Odcisk palca certyfikatu |',
    )
    contextIdentifier: SubunitPermissionsContextIdentifier = Field(
        ...,
        description='Identyfikator podmiotu podrzędnego.\n| Type | Value |\n| --- | --- |\n| Nip | 10 cyfrowy numer NIP |\n| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |',
    )
    description: str = Field(..., description='Opis nadawanych uprawnień.')
    subunitName: Optional[str] = Field(
        None,
        description='Nazwa jednostki podrzędnej. W przypadku jednostki podrzędnej z identyfikatorem wewnętrznym pole jest wymagane.',
    )


class SubunitPermissionsQueryRequest(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    subunitIdentifier: Optional[SubunitPermissionsSubunitIdentifier] = Field(
        None,
        description='Identyfikator jednostki lub podmiotu podrzędnego.\n| Type | Value |\n| --- | --- |\n| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |\n| Nip | 10 cyfrowy numer NIP |',
    )


class InvoiceMetadata(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    ksefNumber: str = Field(..., description='Numer KSeF faktury.')
    invoiceNumber: str = Field(..., description='Numer faktury nadany przez wystawcę.')
    issueDate: date = Field(..., description='Data wystawienia faktury.')
    invoicingDate: AwareDatetime = Field(
        ...,
        description='Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania).',
    )
    acquisitionDate: AwareDatetime = Field(..., description='Data nadania numeru KSeF.')
    permanentStorageDate: AwareDatetime = Field(
        ..., description='Data trwałego zapisu faktury w repozytorium systemu KSeF.'
    )
    seller: InvoiceMetadataSeller = Field(
        ..., description='Dane identyfikujące sprzedawcę.'
    )
    buyer: InvoiceMetadataBuyer = Field(..., description='Dane identyfikujące nabywcę.')
    netAmount: float = Field(..., description='Łączna kwota netto.')
    grossAmount: float = Field(..., description='Łączna kwota brutto.')
    vatAmount: float = Field(..., description='Łączna kwota VAT.')
    currency: str = Field(..., description='Kod waluty.')
    invoicingMode: InvoicingMode = Field(
        ..., description='Tryb fakturowania (online/offline).'
    )
    invoiceType: InvoiceType = Field(
        ...,
        description='Rodzaj faktury.\n| Wartość | Opis |\n| --- | --- |\n| Vat | (FA) Podstawowa |\n| Zal | (FA) Zaliczkowa |\n| Kor | (FA) Korygująca |\n| Roz | (FA) Rozliczeniowa |\n| Upr | (FA) Uproszczona |\n| KorZal | (FA) Korygująca fakturę zaliczkową |\n| KorRoz | (FA) Korygująca fakturę rozliczeniową |\n| VatPef | (PEF) Podstawowowa |\n| VatPefSp | (PEF) Specjalizowana |\n| KorPef | (PEF) Korygująca |\n| VatRr | (RR) Podstawowa |\n| KorVatRr | (RR) Korygująca |\n',
    )
    formCode: FormCode = Field(
        ...,
        description='Struktura dokumentu faktury.\n\nObsługiwane schematy:\n| SystemCode | SchemaVersion | Value |\n| --- | --- | --- |\n| FA (2) | 1-0E | FA |\n| FA (3) | 1-0E | FA |\n| FA_PEF (3) | 2-1 | FA_PEF |\n| FA_KOR_PEF (3) | 2-1 | FA_PEF |\n',
    )
    isSelfInvoicing: bool = Field(
        ..., description='Czy faktura została wystawiona w trybie samofakturowania.'
    )
    hasAttachment: bool = Field(
        ..., description='Określa, czy faktura posiada załącznik.'
    )
    invoiceHash: str = Field(..., description='Skrót SHA256 faktury.')
    hashOfCorrectedInvoice: Optional[str] = Field(
        None, description='Skrót SHA256 korygowanej faktury.'
    )
    thirdSubjects: Optional[List[InvoiceMetadataThirdSubject]] = Field(
        None, description='Lista podmiotów trzecich.'
    )
    authorizedSubject: Optional[InvoiceMetadataAuthorizedSubject] = Field(
        None, description='Podmiot upoważniony.'
    )


class QueryInvoicesMetadataResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    hasMore: bool = Field(
        ..., description='Określa, czy dostępna jest kolejna strona wyników.'
    )
    isTruncated: bool = Field(
        ...,
        description='Określa, czy wynik został obcięty z powodu przekroczenia limitu liczby faktur (10 000).',
    )
    invoices: List[InvoiceMetadata] = Field(
        ..., description='Lista faktur spełniających kryteria.'
    )


class QuerySubordinateEntityRolesResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    roles: List[SubordinateEntityRole] = Field(..., description='Lista ról.')
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )


class QuerySubunitPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
    )
    permissions: List[SubunitPermission] = Field(..., description='Lista uprawnień.')
    hasMore: bool = Field(
        ..., description='Flaga informująca o dostępności kolejnej strony wyników.'
    )
